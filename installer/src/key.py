from Crypto.PublicKey import RSAfrom Crypto.Signature import pkcs1_15from Crypto.Hash import SHA256import base64class SignatureManager:    def __init__(self, private_key_path, public_key_path):        self.private_key_path = private_key_path        self.public_key_path = public_key_path    def sign_data(self, data):        try:            # Загрузка закрытого ключа            with open(self.private_key_path, 'rb') as key_file:                private_key = RSA.import_key(key_file.read())            # Создание хэша данных            h = SHA256.new(data)            # Создание подписи            signature = pkcs1_15.new(private_key).sign(h)            # Возвращение подписи в base64-кодировке            return base64.b64encode(signature).decode('utf-8')        except Exception as e:            print(f"Error while signing data: {str(e)}")    def verify_signature(self, data, signature):        try:            # Загрузка открытого ключа            with open(self.public_key_path, 'rb') as key_file:                public_key = RSA.import_key(key_file.read())            # Создание хэша данных            h = SHA256.new(data)            # Проверка подписи            pkcs1_15.new(public_key).verify(h, base64.b64decode(signature))            print("Signature is valid.")            return True        except (ValueError, TypeError, pkcs1_15.VerificationError) as e:            print(f"Signature verification failed: {str(e)}")            return False# Пример использованияprivate_key_path = "/Users/feodorkalasov/ITMO/Prog/lab3.1/installer/src/private_key.pem"public_key_path = "/Users/feodorkalasov/ITMO/Prog/lab3.1/installer/src/public_key.pem"data_to_sign = b"Hello, world!"# Создание менеджера подписейsignature_manager = SignatureManager(private_key_path, public_key_path)# Создание подписиsignature = signature_manager.sign_data(data_to_sign)# Проверка подписиis_valid = signature_manager.verify_signature(data_to_sign, signature)